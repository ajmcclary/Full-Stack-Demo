import { DMMF, DMMFClass, Engine } from './runtime';
/**
 * Utility Types
 */
export declare type Enumerable<T> = T | Array<T>;
export declare type MergeTruthyValues<R extends object, S extends object> = {
    [key in keyof S | keyof R]: key extends false ? never : key extends keyof S ? S[key] extends false ? never : S[key] : key extends keyof R ? R[key] : never;
};
export declare type CleanupNever<T> = {
    [key in keyof T]: T[key] extends never ? never : key;
}[keyof T];
/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export declare type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
};
declare class PhotonFetcher {
    private readonly photon;
    private readonly engine;
    private readonly debug;
    private readonly hooks?;
    constructor(photon: Photon, engine: Engine, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, path?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    protected unpack(data: any, path: string[], rootField?: string, isList?: boolean): any;
}
/**
 * Client
**/
export declare type Datasources = {
    db?: string;
};
export interface PhotonOptions {
    datasources?: Datasources;
    debug?: boolean | {
        engine?: boolean;
        library?: boolean;
    };
    /**
     * You probably don't want to use this. `__internal` is used by internal tooling.
     */
    __internal?: {
        hooks?: Hooks;
        engine?: {
            cwd?: string;
            binaryPath?: string;
        };
    };
}
export declare type Hooks = {
    beforeRequest?: (options: {
        query: string;
        path: string[];
        rootField?: string;
        typeName?: string;
        document: any;
    }) => any;
};
export declare class Photon {
    private fetcher;
    private readonly dmmf;
    private readonly engine;
    private readonly datamodel;
    private connectionPromise?;
    constructor(options?: PhotonOptions);
    private connectEngine;
    connect(): Promise<void>;
    disconnect(): Promise<void>;
    readonly users: UserDelegate;
    readonly roles: RoleDelegate;
}
export declare const OrderByArg: {
    asc: "asc";
    desc: "desc";
};
export declare type OrderByArg = (typeof OrderByArg)[keyof typeof OrderByArg];
export declare const Group: {
    USER: "USER";
    ADMIN: "ADMIN";
};
export declare type Group = (typeof Group)[keyof typeof Group];
/**
 * Model User
 */
export declare type User = {
    id: string;
    createdAt: string;
    updatedAt: string;
    email: string;
    password: string;
    firstname: string | null;
    lastname: string | null;
    active: boolean;
    group: Group;
    apiKey: string;
};
export declare type UserScalars = 'id' | 'createdAt' | 'updatedAt' | 'email' | 'password' | 'firstname' | 'lastname' | 'active' | 'group' | 'apiKey';
export declare type UserSelect = {
    id?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    email?: boolean;
    password?: boolean;
    firstname?: boolean;
    lastname?: boolean;
    active?: boolean;
    group?: boolean;
    roles?: boolean | FindManyRoleSelectArgsOptional;
    apiKey?: boolean;
};
export declare type UserInclude = {
    roles?: boolean | FindManyRoleIncludeArgsOptional;
};
declare type UserDefault = {
    id: true;
    createdAt: true;
    updatedAt: true;
    email: true;
    password: true;
    firstname: true;
    lastname: true;
    active: true;
    group: true;
    apiKey: true;
};
declare type UserGetSelectPayload<S extends boolean | UserSelect> = S extends true ? User : S extends UserSelect ? {
    [P in CleanupNever<MergeTruthyValues<{}, S>>]: P extends UserScalars ? User[P] : P extends 'roles' ? Array<RoleGetSelectPayload<ExtractFindManyRoleSelectArgs<S[P]>>> : never;
} : never;
declare type UserGetIncludePayload<S extends boolean | UserInclude> = S extends true ? User : S extends UserInclude ? {
    [P in CleanupNever<MergeTruthyValues<UserDefault, S>>]: P extends UserScalars ? User[P] : P extends 'roles' ? Array<RoleGetIncludePayload<ExtractFindManyRoleIncludeArgs<S[P]>>> : never;
} : never;
export interface UserDelegate {
    <T extends FindManyUserArgs>(args?: Subset<T, FindManyUserArgs>): T extends FindManyUserArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyUserSelectArgs ? Promise<Array<UserGetSelectPayload<ExtractFindManyUserSelectArgs<T>>>> : T extends FindManyUserIncludeArgs ? Promise<Array<UserGetIncludePayload<ExtractFindManyUserIncludeArgs<T>>>> : Promise<Array<User>>;
    findOne<T extends FindOneUserArgs>(args: Subset<T, FindOneUserArgs>): T extends FindOneUserArgsRequired ? 'Please either choose `select` or `include`' : T extends FindOneUserSelectArgs ? Promise<UserGetSelectPayload<ExtractFindOneUserSelectArgs<T>>> : T extends FindOneUserIncludeArgs ? Promise<UserGetIncludePayload<ExtractFindOneUserIncludeArgs<T>>> : UserClient<User>;
    findMany<T extends FindManyUserArgs>(args?: Subset<T, FindManyUserArgs>): T extends FindManyUserArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyUserSelectArgs ? Promise<Array<UserGetSelectPayload<ExtractFindManyUserSelectArgs<T>>>> : T extends FindManyUserIncludeArgs ? Promise<Array<UserGetIncludePayload<ExtractFindManyUserIncludeArgs<T>>>> : Promise<Array<User>>;
    create<T extends UserCreateArgs>(args: Subset<T, UserCreateArgs>): T extends UserCreateArgsRequired ? 'Please either choose `select` or `include`' : T extends UserSelectCreateArgs ? Promise<UserGetSelectPayload<ExtractUserSelectCreateArgs<T>>> : T extends UserIncludeCreateArgs ? Promise<UserGetIncludePayload<ExtractUserIncludeCreateArgs<T>>> : UserClient<User>;
    delete<T extends UserDeleteArgs>(args: Subset<T, UserDeleteArgs>): T extends UserDeleteArgsRequired ? 'Please either choose `select` or `include`' : T extends UserSelectDeleteArgs ? Promise<UserGetSelectPayload<ExtractUserSelectDeleteArgs<T>>> : T extends UserIncludeDeleteArgs ? Promise<UserGetIncludePayload<ExtractUserIncludeDeleteArgs<T>>> : UserClient<User>;
    update<T extends UserUpdateArgs>(args: Subset<T, UserUpdateArgs>): T extends UserUpdateArgsRequired ? 'Please either choose `select` or `include`' : T extends UserSelectUpdateArgs ? Promise<UserGetSelectPayload<ExtractUserSelectUpdateArgs<T>>> : T extends UserIncludeUpdateArgs ? Promise<UserGetIncludePayload<ExtractUserIncludeUpdateArgs<T>>> : UserClient<User>;
    deleteMany<T extends UserDeleteManyArgs>(args: Subset<T, UserDeleteManyArgs>): Promise<BatchPayload>;
    updateMany<T extends UserUpdateManyArgs>(args: Subset<T, UserUpdateManyArgs>): Promise<BatchPayload>;
    upsert<T extends UserUpsertArgs>(args: Subset<T, UserUpsertArgs>): T extends UserUpsertArgsRequired ? 'Please either choose `select` or `include`' : T extends UserSelectUpsertArgs ? Promise<UserGetSelectPayload<ExtractUserSelectUpsertArgs<T>>> : T extends UserIncludeUpsertArgs ? Promise<UserGetIncludePayload<ExtractUserIncludeUpsertArgs<T>>> : UserClient<User>;
    count(): Promise<number>;
}
export declare class UserClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _path;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: DMMFClass, _fetcher: PhotonFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _path: string[], _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PhotonPromise';
    roles<T extends FindManyRoleArgs = {}>(args?: Subset<T, FindManyRoleArgs>): T extends FindManyRoleArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyRoleSelectArgs ? Promise<Array<RoleGetSelectPayload<ExtractFindManyRoleSelectArgs<T>>>> : T extends FindManyRoleIncludeArgs ? Promise<Array<RoleGetIncludePayload<ExtractFindManyRoleIncludeArgs<T>>>> : Promise<Array<Role>>;
    private readonly _document;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}
/**
 * User findOne
 */
export declare type FindOneUserArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
    where: UserWhereUniqueInput;
};
export declare type FindOneUserArgsRequired = {
    select: UserSelect;
    include: UserInclude;
    where: UserWhereUniqueInput;
};
export declare type FindOneUserSelectArgs = {
    select: UserSelect;
    where: UserWhereUniqueInput;
};
export declare type FindOneUserSelectArgsOptional = {
    select?: UserSelect | null;
    where: UserWhereUniqueInput;
};
export declare type FindOneUserIncludeArgs = {
    include: UserInclude;
    where: UserWhereUniqueInput;
};
export declare type FindOneUserIncludeArgsOptional = {
    include?: UserInclude | null;
    where: UserWhereUniqueInput;
};
export declare type ExtractFindOneUserSelectArgs<S extends undefined | boolean | FindOneUserSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindOneUserSelectArgs ? S['select'] : true;
export declare type ExtractFindOneUserIncludeArgs<S extends undefined | boolean | FindOneUserIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindOneUserIncludeArgs ? S['include'] : true;
/**
 * User findMany
 */
export declare type FindManyUserArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
    where?: UserWhereInput | null;
    orderBy?: UserOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyUserArgsRequired = {
    select: UserSelect;
    include: UserInclude;
    where?: UserWhereInput | null;
    orderBy?: UserOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyUserSelectArgs = {
    select: UserSelect;
    where?: UserWhereInput | null;
    orderBy?: UserOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyUserSelectArgsOptional = {
    select?: UserSelect | null;
    where?: UserWhereInput | null;
    orderBy?: UserOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyUserIncludeArgs = {
    include: UserInclude;
    where?: UserWhereInput | null;
    orderBy?: UserOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyUserIncludeArgsOptional = {
    include?: UserInclude | null;
    where?: UserWhereInput | null;
    orderBy?: UserOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type ExtractFindManyUserSelectArgs<S extends undefined | boolean | FindManyUserSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindManyUserSelectArgs ? S['select'] : true;
export declare type ExtractFindManyUserIncludeArgs<S extends undefined | boolean | FindManyUserIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindManyUserIncludeArgs ? S['include'] : true;
/**
 * User create
 */
export declare type UserCreateArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
    data: UserCreateInput;
};
export declare type UserCreateArgsRequired = {
    select: UserSelect;
    include: UserInclude;
    data: UserCreateInput;
};
export declare type UserSelectCreateArgs = {
    select: UserSelect;
    data: UserCreateInput;
};
export declare type UserSelectCreateArgsOptional = {
    select?: UserSelect | null;
    data: UserCreateInput;
};
export declare type UserIncludeCreateArgs = {
    include: UserInclude;
    data: UserCreateInput;
};
export declare type UserIncludeCreateArgsOptional = {
    include?: UserInclude | null;
    data: UserCreateInput;
};
export declare type ExtractUserSelectCreateArgs<S extends undefined | boolean | UserSelectCreateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserSelectCreateArgs ? S['select'] : true;
export declare type ExtractUserIncludeCreateArgs<S extends undefined | boolean | UserIncludeCreateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserIncludeCreateArgs ? S['include'] : true;
/**
 * User update
 */
export declare type UserUpdateArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
};
export declare type UserUpdateArgsRequired = {
    select: UserSelect;
    include: UserInclude;
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
};
export declare type UserSelectUpdateArgs = {
    select: UserSelect;
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
};
export declare type UserSelectUpdateArgsOptional = {
    select?: UserSelect | null;
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
};
export declare type UserIncludeUpdateArgs = {
    include: UserInclude;
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
};
export declare type UserIncludeUpdateArgsOptional = {
    include?: UserInclude | null;
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
};
export declare type ExtractUserSelectUpdateArgs<S extends undefined | boolean | UserSelectUpdateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserSelectUpdateArgs ? S['select'] : true;
export declare type ExtractUserIncludeUpdateArgs<S extends undefined | boolean | UserIncludeUpdateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserIncludeUpdateArgs ? S['include'] : true;
/**
 * User updateMany
 */
export declare type UserUpdateManyArgs = {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput | null;
};
/**
 * User upsert
 */
export declare type UserUpsertArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
};
export declare type UserUpsertArgsRequired = {
    select: UserSelect;
    include: UserInclude;
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
};
export declare type UserSelectUpsertArgs = {
    select: UserSelect;
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
};
export declare type UserSelectUpsertArgsOptional = {
    select?: UserSelect | null;
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
};
export declare type UserIncludeUpsertArgs = {
    include: UserInclude;
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
};
export declare type UserIncludeUpsertArgsOptional = {
    include?: UserInclude | null;
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
};
export declare type ExtractUserSelectUpsertArgs<S extends undefined | boolean | UserSelectUpsertArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserSelectUpsertArgs ? S['select'] : true;
export declare type ExtractUserIncludeUpsertArgs<S extends undefined | boolean | UserIncludeUpsertArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserIncludeUpsertArgs ? S['include'] : true;
/**
 * User delete
 */
export declare type UserDeleteArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
    where: UserWhereUniqueInput;
};
export declare type UserDeleteArgsRequired = {
    select: UserSelect;
    include: UserInclude;
    where: UserWhereUniqueInput;
};
export declare type UserSelectDeleteArgs = {
    select: UserSelect;
    where: UserWhereUniqueInput;
};
export declare type UserSelectDeleteArgsOptional = {
    select?: UserSelect | null;
    where: UserWhereUniqueInput;
};
export declare type UserIncludeDeleteArgs = {
    include: UserInclude;
    where: UserWhereUniqueInput;
};
export declare type UserIncludeDeleteArgsOptional = {
    include?: UserInclude | null;
    where: UserWhereUniqueInput;
};
export declare type ExtractUserSelectDeleteArgs<S extends undefined | boolean | UserSelectDeleteArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserSelectDeleteArgs ? S['select'] : true;
export declare type ExtractUserIncludeDeleteArgs<S extends undefined | boolean | UserIncludeDeleteArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserIncludeDeleteArgs ? S['include'] : true;
/**
 * User deleteMany
 */
export declare type UserDeleteManyArgs = {
    where?: UserWhereInput | null;
};
/**
 * User without action
 */
export declare type UserArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
};
export declare type UserArgsRequired = {
    select: UserSelect;
    include: UserInclude;
};
export declare type UserSelectArgs = {
    select: UserSelect;
};
export declare type UserSelectArgsOptional = {
    select?: UserSelect | null;
};
export declare type UserIncludeArgs = {
    include: UserInclude;
};
export declare type UserIncludeArgsOptional = {
    include?: UserInclude | null;
};
export declare type ExtractUserSelectArgs<S extends undefined | boolean | UserSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserSelectArgs ? S['select'] : true;
export declare type ExtractUserIncludeArgs<S extends undefined | boolean | UserIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserIncludeArgs ? S['include'] : true;
/**
 * Model Role
 */
export declare type Role = {
    id: string;
    name: string;
    description: string;
};
export declare type RoleScalars = 'id' | 'name' | 'description';
export declare type RoleSelect = {
    id?: boolean;
    name?: boolean;
    description?: boolean;
    users?: boolean | FindManyUserSelectArgsOptional;
};
export declare type RoleInclude = {
    users?: boolean | FindManyUserIncludeArgsOptional;
};
declare type RoleDefault = {
    id: true;
    name: true;
    description: true;
};
declare type RoleGetSelectPayload<S extends boolean | RoleSelect> = S extends true ? Role : S extends RoleSelect ? {
    [P in CleanupNever<MergeTruthyValues<{}, S>>]: P extends RoleScalars ? Role[P] : P extends 'users' ? Array<UserGetSelectPayload<ExtractFindManyUserSelectArgs<S[P]>>> : never;
} : never;
declare type RoleGetIncludePayload<S extends boolean | RoleInclude> = S extends true ? Role : S extends RoleInclude ? {
    [P in CleanupNever<MergeTruthyValues<RoleDefault, S>>]: P extends RoleScalars ? Role[P] : P extends 'users' ? Array<UserGetIncludePayload<ExtractFindManyUserIncludeArgs<S[P]>>> : never;
} : never;
export interface RoleDelegate {
    <T extends FindManyRoleArgs>(args?: Subset<T, FindManyRoleArgs>): T extends FindManyRoleArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyRoleSelectArgs ? Promise<Array<RoleGetSelectPayload<ExtractFindManyRoleSelectArgs<T>>>> : T extends FindManyRoleIncludeArgs ? Promise<Array<RoleGetIncludePayload<ExtractFindManyRoleIncludeArgs<T>>>> : Promise<Array<Role>>;
    findOne<T extends FindOneRoleArgs>(args: Subset<T, FindOneRoleArgs>): T extends FindOneRoleArgsRequired ? 'Please either choose `select` or `include`' : T extends FindOneRoleSelectArgs ? Promise<RoleGetSelectPayload<ExtractFindOneRoleSelectArgs<T>>> : T extends FindOneRoleIncludeArgs ? Promise<RoleGetIncludePayload<ExtractFindOneRoleIncludeArgs<T>>> : RoleClient<Role>;
    findMany<T extends FindManyRoleArgs>(args?: Subset<T, FindManyRoleArgs>): T extends FindManyRoleArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyRoleSelectArgs ? Promise<Array<RoleGetSelectPayload<ExtractFindManyRoleSelectArgs<T>>>> : T extends FindManyRoleIncludeArgs ? Promise<Array<RoleGetIncludePayload<ExtractFindManyRoleIncludeArgs<T>>>> : Promise<Array<Role>>;
    create<T extends RoleCreateArgs>(args: Subset<T, RoleCreateArgs>): T extends RoleCreateArgsRequired ? 'Please either choose `select` or `include`' : T extends RoleSelectCreateArgs ? Promise<RoleGetSelectPayload<ExtractRoleSelectCreateArgs<T>>> : T extends RoleIncludeCreateArgs ? Promise<RoleGetIncludePayload<ExtractRoleIncludeCreateArgs<T>>> : RoleClient<Role>;
    delete<T extends RoleDeleteArgs>(args: Subset<T, RoleDeleteArgs>): T extends RoleDeleteArgsRequired ? 'Please either choose `select` or `include`' : T extends RoleSelectDeleteArgs ? Promise<RoleGetSelectPayload<ExtractRoleSelectDeleteArgs<T>>> : T extends RoleIncludeDeleteArgs ? Promise<RoleGetIncludePayload<ExtractRoleIncludeDeleteArgs<T>>> : RoleClient<Role>;
    update<T extends RoleUpdateArgs>(args: Subset<T, RoleUpdateArgs>): T extends RoleUpdateArgsRequired ? 'Please either choose `select` or `include`' : T extends RoleSelectUpdateArgs ? Promise<RoleGetSelectPayload<ExtractRoleSelectUpdateArgs<T>>> : T extends RoleIncludeUpdateArgs ? Promise<RoleGetIncludePayload<ExtractRoleIncludeUpdateArgs<T>>> : RoleClient<Role>;
    deleteMany<T extends RoleDeleteManyArgs>(args: Subset<T, RoleDeleteManyArgs>): Promise<BatchPayload>;
    updateMany<T extends RoleUpdateManyArgs>(args: Subset<T, RoleUpdateManyArgs>): Promise<BatchPayload>;
    upsert<T extends RoleUpsertArgs>(args: Subset<T, RoleUpsertArgs>): T extends RoleUpsertArgsRequired ? 'Please either choose `select` or `include`' : T extends RoleSelectUpsertArgs ? Promise<RoleGetSelectPayload<ExtractRoleSelectUpsertArgs<T>>> : T extends RoleIncludeUpsertArgs ? Promise<RoleGetIncludePayload<ExtractRoleIncludeUpsertArgs<T>>> : RoleClient<Role>;
    count(): Promise<number>;
}
export declare class RoleClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _path;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: DMMFClass, _fetcher: PhotonFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _path: string[], _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PhotonPromise';
    users<T extends FindManyUserArgs = {}>(args?: Subset<T, FindManyUserArgs>): T extends FindManyUserArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyUserSelectArgs ? Promise<Array<UserGetSelectPayload<ExtractFindManyUserSelectArgs<T>>>> : T extends FindManyUserIncludeArgs ? Promise<Array<UserGetIncludePayload<ExtractFindManyUserIncludeArgs<T>>>> : Promise<Array<User>>;
    private readonly _document;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}
/**
 * Role findOne
 */
export declare type FindOneRoleArgs = {
    select?: RoleSelect | null;
    include?: RoleInclude | null;
    where: RoleWhereUniqueInput;
};
export declare type FindOneRoleArgsRequired = {
    select: RoleSelect;
    include: RoleInclude;
    where: RoleWhereUniqueInput;
};
export declare type FindOneRoleSelectArgs = {
    select: RoleSelect;
    where: RoleWhereUniqueInput;
};
export declare type FindOneRoleSelectArgsOptional = {
    select?: RoleSelect | null;
    where: RoleWhereUniqueInput;
};
export declare type FindOneRoleIncludeArgs = {
    include: RoleInclude;
    where: RoleWhereUniqueInput;
};
export declare type FindOneRoleIncludeArgsOptional = {
    include?: RoleInclude | null;
    where: RoleWhereUniqueInput;
};
export declare type ExtractFindOneRoleSelectArgs<S extends undefined | boolean | FindOneRoleSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindOneRoleSelectArgs ? S['select'] : true;
export declare type ExtractFindOneRoleIncludeArgs<S extends undefined | boolean | FindOneRoleIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindOneRoleIncludeArgs ? S['include'] : true;
/**
 * Role findMany
 */
export declare type FindManyRoleArgs = {
    select?: RoleSelect | null;
    include?: RoleInclude | null;
    where?: RoleWhereInput | null;
    orderBy?: RoleOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyRoleArgsRequired = {
    select: RoleSelect;
    include: RoleInclude;
    where?: RoleWhereInput | null;
    orderBy?: RoleOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyRoleSelectArgs = {
    select: RoleSelect;
    where?: RoleWhereInput | null;
    orderBy?: RoleOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyRoleSelectArgsOptional = {
    select?: RoleSelect | null;
    where?: RoleWhereInput | null;
    orderBy?: RoleOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyRoleIncludeArgs = {
    include: RoleInclude;
    where?: RoleWhereInput | null;
    orderBy?: RoleOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyRoleIncludeArgsOptional = {
    include?: RoleInclude | null;
    where?: RoleWhereInput | null;
    orderBy?: RoleOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type ExtractFindManyRoleSelectArgs<S extends undefined | boolean | FindManyRoleSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindManyRoleSelectArgs ? S['select'] : true;
export declare type ExtractFindManyRoleIncludeArgs<S extends undefined | boolean | FindManyRoleIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindManyRoleIncludeArgs ? S['include'] : true;
/**
 * Role create
 */
export declare type RoleCreateArgs = {
    select?: RoleSelect | null;
    include?: RoleInclude | null;
    data: RoleCreateInput;
};
export declare type RoleCreateArgsRequired = {
    select: RoleSelect;
    include: RoleInclude;
    data: RoleCreateInput;
};
export declare type RoleSelectCreateArgs = {
    select: RoleSelect;
    data: RoleCreateInput;
};
export declare type RoleSelectCreateArgsOptional = {
    select?: RoleSelect | null;
    data: RoleCreateInput;
};
export declare type RoleIncludeCreateArgs = {
    include: RoleInclude;
    data: RoleCreateInput;
};
export declare type RoleIncludeCreateArgsOptional = {
    include?: RoleInclude | null;
    data: RoleCreateInput;
};
export declare type ExtractRoleSelectCreateArgs<S extends undefined | boolean | RoleSelectCreateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends RoleSelectCreateArgs ? S['select'] : true;
export declare type ExtractRoleIncludeCreateArgs<S extends undefined | boolean | RoleIncludeCreateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends RoleIncludeCreateArgs ? S['include'] : true;
/**
 * Role update
 */
export declare type RoleUpdateArgs = {
    select?: RoleSelect | null;
    include?: RoleInclude | null;
    data: RoleUpdateInput;
    where: RoleWhereUniqueInput;
};
export declare type RoleUpdateArgsRequired = {
    select: RoleSelect;
    include: RoleInclude;
    data: RoleUpdateInput;
    where: RoleWhereUniqueInput;
};
export declare type RoleSelectUpdateArgs = {
    select: RoleSelect;
    data: RoleUpdateInput;
    where: RoleWhereUniqueInput;
};
export declare type RoleSelectUpdateArgsOptional = {
    select?: RoleSelect | null;
    data: RoleUpdateInput;
    where: RoleWhereUniqueInput;
};
export declare type RoleIncludeUpdateArgs = {
    include: RoleInclude;
    data: RoleUpdateInput;
    where: RoleWhereUniqueInput;
};
export declare type RoleIncludeUpdateArgsOptional = {
    include?: RoleInclude | null;
    data: RoleUpdateInput;
    where: RoleWhereUniqueInput;
};
export declare type ExtractRoleSelectUpdateArgs<S extends undefined | boolean | RoleSelectUpdateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends RoleSelectUpdateArgs ? S['select'] : true;
export declare type ExtractRoleIncludeUpdateArgs<S extends undefined | boolean | RoleIncludeUpdateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends RoleIncludeUpdateArgs ? S['include'] : true;
/**
 * Role updateMany
 */
export declare type RoleUpdateManyArgs = {
    data: RoleUpdateManyMutationInput;
    where?: RoleWhereInput | null;
};
/**
 * Role upsert
 */
export declare type RoleUpsertArgs = {
    select?: RoleSelect | null;
    include?: RoleInclude | null;
    where: RoleWhereUniqueInput;
    create: RoleCreateInput;
    update: RoleUpdateInput;
};
export declare type RoleUpsertArgsRequired = {
    select: RoleSelect;
    include: RoleInclude;
    where: RoleWhereUniqueInput;
    create: RoleCreateInput;
    update: RoleUpdateInput;
};
export declare type RoleSelectUpsertArgs = {
    select: RoleSelect;
    where: RoleWhereUniqueInput;
    create: RoleCreateInput;
    update: RoleUpdateInput;
};
export declare type RoleSelectUpsertArgsOptional = {
    select?: RoleSelect | null;
    where: RoleWhereUniqueInput;
    create: RoleCreateInput;
    update: RoleUpdateInput;
};
export declare type RoleIncludeUpsertArgs = {
    include: RoleInclude;
    where: RoleWhereUniqueInput;
    create: RoleCreateInput;
    update: RoleUpdateInput;
};
export declare type RoleIncludeUpsertArgsOptional = {
    include?: RoleInclude | null;
    where: RoleWhereUniqueInput;
    create: RoleCreateInput;
    update: RoleUpdateInput;
};
export declare type ExtractRoleSelectUpsertArgs<S extends undefined | boolean | RoleSelectUpsertArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends RoleSelectUpsertArgs ? S['select'] : true;
export declare type ExtractRoleIncludeUpsertArgs<S extends undefined | boolean | RoleIncludeUpsertArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends RoleIncludeUpsertArgs ? S['include'] : true;
/**
 * Role delete
 */
export declare type RoleDeleteArgs = {
    select?: RoleSelect | null;
    include?: RoleInclude | null;
    where: RoleWhereUniqueInput;
};
export declare type RoleDeleteArgsRequired = {
    select: RoleSelect;
    include: RoleInclude;
    where: RoleWhereUniqueInput;
};
export declare type RoleSelectDeleteArgs = {
    select: RoleSelect;
    where: RoleWhereUniqueInput;
};
export declare type RoleSelectDeleteArgsOptional = {
    select?: RoleSelect | null;
    where: RoleWhereUniqueInput;
};
export declare type RoleIncludeDeleteArgs = {
    include: RoleInclude;
    where: RoleWhereUniqueInput;
};
export declare type RoleIncludeDeleteArgsOptional = {
    include?: RoleInclude | null;
    where: RoleWhereUniqueInput;
};
export declare type ExtractRoleSelectDeleteArgs<S extends undefined | boolean | RoleSelectDeleteArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends RoleSelectDeleteArgs ? S['select'] : true;
export declare type ExtractRoleIncludeDeleteArgs<S extends undefined | boolean | RoleIncludeDeleteArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends RoleIncludeDeleteArgs ? S['include'] : true;
/**
 * Role deleteMany
 */
export declare type RoleDeleteManyArgs = {
    where?: RoleWhereInput | null;
};
/**
 * Role without action
 */
export declare type RoleArgs = {
    select?: RoleSelect | null;
    include?: RoleInclude | null;
};
export declare type RoleArgsRequired = {
    select: RoleSelect;
    include: RoleInclude;
};
export declare type RoleSelectArgs = {
    select: RoleSelect;
};
export declare type RoleSelectArgsOptional = {
    select?: RoleSelect | null;
};
export declare type RoleIncludeArgs = {
    include: RoleInclude;
};
export declare type RoleIncludeArgsOptional = {
    include?: RoleInclude | null;
};
export declare type ExtractRoleSelectArgs<S extends undefined | boolean | RoleSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends RoleSelectArgs ? S['select'] : true;
export declare type ExtractRoleIncludeArgs<S extends undefined | boolean | RoleIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends RoleIncludeArgs ? S['include'] : true;
/**
 * Deep Input Types
 */
export declare type RoleWhereInput = {
    id?: string | StringFilter | null;
    name?: string | StringFilter | null;
    description?: string | StringFilter | null;
    users?: UserFilter | null;
    AND?: Enumerable<RoleWhereInput> | null;
    OR?: Enumerable<RoleWhereInput> | null;
    NOT?: Enumerable<RoleWhereInput> | null;
};
export declare type UserWhereInput = {
    id?: string | StringFilter | null;
    createdAt?: string | Date | DateTimeFilter | null;
    updatedAt?: string | Date | DateTimeFilter | null;
    email?: string | StringFilter | null;
    password?: string | StringFilter | null;
    firstname?: string | NullableStringFilter | null | null;
    lastname?: string | NullableStringFilter | null | null;
    active?: boolean | BooleanFilter | null;
    group?: Group | GroupFilter | null;
    roles?: RoleFilter | null;
    apiKey?: string | StringFilter | null;
    AND?: Enumerable<UserWhereInput> | null;
    OR?: Enumerable<UserWhereInput> | null;
    NOT?: Enumerable<UserWhereInput> | null;
};
export declare type UserWhereUniqueInput = {
    id?: string | null;
    email?: string | null;
    apiKey?: string | null;
};
export declare type RoleWhereUniqueInput = {
    id?: string | null;
    name?: string | null;
};
export declare type RoleCreateWithoutUsersInput = {
    id?: string | null;
    name: string;
    description: string;
};
export declare type RoleCreateManyWithoutRolesInput = {
    create?: Enumerable<RoleCreateWithoutUsersInput> | null;
    connect?: Enumerable<RoleWhereUniqueInput> | null;
};
export declare type UserCreateInput = {
    id?: string | null;
    createdAt?: string | Date | null;
    updatedAt?: string | Date | null;
    email: string;
    password: string;
    firstname?: string | null;
    lastname?: string | null;
    active?: boolean | null;
    group?: Group | null;
    apiKey: string;
    roles?: RoleCreateManyWithoutRolesInput | null;
};
export declare type RoleUpdateWithoutUsersDataInput = {
    id?: string | null;
    name?: string | null;
    description?: string | null;
};
export declare type RoleUpdateWithWhereUniqueWithoutUsersInput = {
    where: RoleWhereUniqueInput;
    data: RoleUpdateWithoutUsersDataInput;
};
export declare type RoleScalarWhereInput = {
    id?: string | StringFilter | null;
    name?: string | StringFilter | null;
    description?: string | StringFilter | null;
    users?: UserFilter | null;
    AND?: Enumerable<RoleScalarWhereInput> | null;
    OR?: Enumerable<RoleScalarWhereInput> | null;
    NOT?: Enumerable<RoleScalarWhereInput> | null;
};
export declare type RoleUpdateManyDataInput = {
    id?: string | null;
    name?: string | null;
    description?: string | null;
};
export declare type RoleUpdateManyWithWhereNestedInput = {
    where: RoleScalarWhereInput;
    data: RoleUpdateManyDataInput;
};
export declare type RoleUpsertWithWhereUniqueWithoutUsersInput = {
    where: RoleWhereUniqueInput;
    update: RoleUpdateWithoutUsersDataInput;
    create: RoleCreateWithoutUsersInput;
};
export declare type RoleUpdateManyWithoutUsersInput = {
    create?: Enumerable<RoleCreateWithoutUsersInput> | null;
    connect?: Enumerable<RoleWhereUniqueInput> | null;
    set?: Enumerable<RoleWhereUniqueInput> | null;
    disconnect?: Enumerable<RoleWhereUniqueInput> | null;
    delete?: Enumerable<RoleWhereUniqueInput> | null;
    update?: Enumerable<RoleUpdateWithWhereUniqueWithoutUsersInput> | null;
    updateMany?: Enumerable<RoleUpdateManyWithWhereNestedInput> | null;
    deleteMany?: Enumerable<RoleScalarWhereInput> | null;
    upsert?: Enumerable<RoleUpsertWithWhereUniqueWithoutUsersInput> | null;
};
export declare type UserUpdateInput = {
    id?: string | null;
    createdAt?: string | Date | null;
    updatedAt?: string | Date | null;
    email?: string | null;
    password?: string | null;
    firstname?: string | null;
    lastname?: string | null;
    active?: boolean | null;
    group?: Group | null;
    apiKey?: string | null;
    roles?: RoleUpdateManyWithoutUsersInput | null;
};
export declare type UserUpdateManyMutationInput = {
    id?: string | null;
    createdAt?: string | Date | null;
    updatedAt?: string | Date | null;
    email?: string | null;
    password?: string | null;
    firstname?: string | null;
    lastname?: string | null;
    active?: boolean | null;
    group?: Group | null;
    apiKey?: string | null;
};
export declare type UserCreateWithoutRolesInput = {
    id?: string | null;
    createdAt?: string | Date | null;
    updatedAt?: string | Date | null;
    email: string;
    password: string;
    firstname?: string | null;
    lastname?: string | null;
    active?: boolean | null;
    group?: Group | null;
    apiKey: string;
};
export declare type UserCreateManyWithoutUsersInput = {
    create?: Enumerable<UserCreateWithoutRolesInput> | null;
    connect?: Enumerable<UserWhereUniqueInput> | null;
};
export declare type RoleCreateInput = {
    id?: string | null;
    name: string;
    description: string;
    users?: UserCreateManyWithoutUsersInput | null;
};
export declare type UserUpdateWithoutRolesDataInput = {
    id?: string | null;
    createdAt?: string | Date | null;
    updatedAt?: string | Date | null;
    email?: string | null;
    password?: string | null;
    firstname?: string | null;
    lastname?: string | null;
    active?: boolean | null;
    group?: Group | null;
    apiKey?: string | null;
};
export declare type UserUpdateWithWhereUniqueWithoutRolesInput = {
    where: UserWhereUniqueInput;
    data: UserUpdateWithoutRolesDataInput;
};
export declare type UserScalarWhereInput = {
    id?: string | StringFilter | null;
    createdAt?: string | Date | DateTimeFilter | null;
    updatedAt?: string | Date | DateTimeFilter | null;
    email?: string | StringFilter | null;
    password?: string | StringFilter | null;
    firstname?: string | NullableStringFilter | null | null;
    lastname?: string | NullableStringFilter | null | null;
    active?: boolean | BooleanFilter | null;
    group?: Group | GroupFilter | null;
    roles?: RoleFilter | null;
    apiKey?: string | StringFilter | null;
    AND?: Enumerable<UserScalarWhereInput> | null;
    OR?: Enumerable<UserScalarWhereInput> | null;
    NOT?: Enumerable<UserScalarWhereInput> | null;
};
export declare type UserUpdateManyDataInput = {
    id?: string | null;
    createdAt?: string | Date | null;
    updatedAt?: string | Date | null;
    email?: string | null;
    password?: string | null;
    firstname?: string | null;
    lastname?: string | null;
    active?: boolean | null;
    group?: Group | null;
    apiKey?: string | null;
};
export declare type UserUpdateManyWithWhereNestedInput = {
    where: UserScalarWhereInput;
    data: UserUpdateManyDataInput;
};
export declare type UserUpsertWithWhereUniqueWithoutRolesInput = {
    where: UserWhereUniqueInput;
    update: UserUpdateWithoutRolesDataInput;
    create: UserCreateWithoutRolesInput;
};
export declare type UserUpdateManyWithoutRolesInput = {
    create?: Enumerable<UserCreateWithoutRolesInput> | null;
    connect?: Enumerable<UserWhereUniqueInput> | null;
    set?: Enumerable<UserWhereUniqueInput> | null;
    disconnect?: Enumerable<UserWhereUniqueInput> | null;
    delete?: Enumerable<UserWhereUniqueInput> | null;
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutRolesInput> | null;
    updateMany?: Enumerable<UserUpdateManyWithWhereNestedInput> | null;
    deleteMany?: Enumerable<UserScalarWhereInput> | null;
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutRolesInput> | null;
};
export declare type RoleUpdateInput = {
    id?: string | null;
    name?: string | null;
    description?: string | null;
    users?: UserUpdateManyWithoutRolesInput | null;
};
export declare type RoleUpdateManyMutationInput = {
    id?: string | null;
    name?: string | null;
    description?: string | null;
};
export declare type StringFilter = {
    equals?: string | null;
    not?: string | StringFilter | null;
    in?: Enumerable<string> | null;
    notIn?: Enumerable<string> | null;
    lt?: string | null;
    lte?: string | null;
    gt?: string | null;
    gte?: string | null;
    contains?: string | null;
    startsWith?: string | null;
    endsWith?: string | null;
};
export declare type UserFilter = {
    every?: UserWhereInput | null;
    some?: UserWhereInput | null;
    none?: UserWhereInput | null;
};
export declare type DateTimeFilter = {
    equals?: string | Date | null;
    not?: string | Date | DateTimeFilter | null;
    in?: Enumerable<string | Date> | null;
    notIn?: Enumerable<string | Date> | null;
    lt?: string | Date | null;
    lte?: string | Date | null;
    gt?: string | Date | null;
    gte?: string | Date | null;
};
export declare type NullableStringFilter = {
    equals?: string | null | null;
    not?: string | null | NullableStringFilter | null;
    in?: Enumerable<string> | null;
    notIn?: Enumerable<string> | null;
    lt?: string | null;
    lte?: string | null;
    gt?: string | null;
    gte?: string | null;
    contains?: string | null;
    startsWith?: string | null;
    endsWith?: string | null;
};
export declare type BooleanFilter = {
    equals?: boolean | null;
    not?: boolean | BooleanFilter | null;
};
export declare type GroupFilter = {};
export declare type RoleFilter = {
    every?: RoleWhereInput | null;
    some?: RoleWhereInput | null;
    none?: RoleWhereInput | null;
};
export declare type UserOrderByInput = {
    id?: OrderByArg | null;
    createdAt?: OrderByArg | null;
    updatedAt?: OrderByArg | null;
    email?: OrderByArg | null;
    password?: OrderByArg | null;
    firstname?: OrderByArg | null;
    lastname?: OrderByArg | null;
    active?: OrderByArg | null;
    group?: OrderByArg | null;
    apiKey?: OrderByArg | null;
};
export declare type RoleOrderByInput = {
    id?: OrderByArg | null;
    name?: OrderByArg | null;
    description?: OrderByArg | null;
};
/**
 * Batch Payload for updateMany & deleteMany
 */
export declare type BatchPayload = {
    count: number;
};
/**
 * DMMF
 */
export declare const dmmf: DMMF.Document;
export {};
